{"ts":1349215326098,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/******************************************************************************\n * MATRIX CONVENTIONS TO POSSIBLY DOCUMENT\n * \n * We create one variable 'Matrix' to attach all our handler functions. \n * It is treated like a 'static class'.\n * All matrices assumed to be 4D i.e. a 3D matrix embedded in a 4x4 identity.\n * All matrices stored in flattened array form.\n ******************************************************************************/\nvar Matrix = {}; \n\n/***********************\n *  SETTER FUNCTIONS  *\n ***********************/\nMatrix.setTo = function(A) {\n    return A;\n};\n\nMatrix.toIdentity = function() {\n    return [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];\n};\n    \nMatrix.toZero = function() {\n    return [0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0];\n};\n\nMatrix.toOnes = function() {\n   return [1,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1];\n};\n\nMatrix.embed = function(A3x3) {\n    // Embed a 3x3 matrix in top L corner of a 4x4 identity matrix.\n    var A4x4 = Matrix.toIdentity();\n    A4x4[0] = A3x3[0];  A4x4[1]  = A3x3[1];  A4x4[2]  = A3x3[2]; \n    A4x4[5] = A3x3[4];  A4x4[6]  = A3x3[5];  A4x4[7]  = A3x3[6];\n    A4x4[9] = A3x3[7];  A4x4[10] = A3x3[8];  A4x4[11] = A3x3[9];\n    return A4x4;\n};\n\nMatrix.toWebGL = function(A) {\n    // TO DO\n};\n\n/****************\n *  OPERATIONS  *\n ****************/\nMatrix.multiply3x3 = function(A, B) {\n    var mtmp = [];\n    mtmp[0] = A[0]*B[0] + A[1]*B[3] + A[2]*B[6];\n    mtmp[1] = A[0]*B[1] + A[1]*B[4] + A[2]*B[7];\n    mtmp[2] = A[0]*B[2] + A[1]*B[5] + A[2]*B[8];  \n    \n    mtmp[3] = A[3]*B[0] + A[4]*B[3] + A[5]*B[6];\n    mtmp[4] = A[3]*B[1] + A[4]*B[4] + A[5]*B[7];\n    mtmp[5] = A[3]*B[2] + A[4]*B[5] + A[5]*B[8];\n    \n    mtmp[6] = A[6]*B[0] + A[7]*B[3] + A[8]*B[6];\n    mtmp[7] = A[6]*B[1] + A[7]*B[4] + A[8]*B[7];\n    mtmp[8] = A[6]*B[2] + A[7]*B[5] + A[8]*B[8];\n    return mtmp;\n};\n\nMatrix.multiply4x4 = function(A, B) {\n    var mtmp = [];\n    mtmp[0]  = A[0]*B[0]  + A[1]*B[4]  + A[2]*B[8]   + A[3]*B[12];\n    mtmp[1]  = A[0]*B[1]  + A[1]*B[5]  + A[2]*B[9]   + A[3]*B[13];\n    mtmp[2]  = A[0]*B[2]  + A[1]*B[6]  + A[2]*B[10]  + A[3]*B[14];\n    mtmp[3]  = A[0]*B[3]  + A[1]*B[7]  + A[2]*B[11]  + A[3]*B[15];\n    \n    mtmp[4]  = A[4]*B[0]  + A[5]*B[4]  + A[6]*B[8]   + A[7]*B[12];\n    mtmp[5]  = A[4]*B[1]  + A[5]*B[5]  + A[6]*B[9]   + A[7]*B[13];\n    mtmp[6]  = A[4]*B[2]  + A[5]*B[6]  + A[6]*B[10]  + A[7]*B[14];\n    mtmp[7]  = A[4]*B[3]  + A[5]*B[7]  + A[6]*B[11]  + A[7]*B[15];\n    \n    mtmp[8]  = A[8]*B[0]  + A[9]*B[4]  + A[10]*B[8]  + A[11]*B[12];\n    mtmp[9]  = A[8]*B[1]  + A[9]*B[5]  + A[10]*B[9]  + A[11]*B[13];\n    mtmp[10] = A[8]*B[2]  + A[9]*B[6]  + A[10]*B[10] + A[11]*B[14];\n    mtmp[11] = A[8]*B[3]  + A[9]*B[7]  + A[10]*B[11] + A[11]*B[15];\n    \n    mtmp[12] = A[12]*B[0] + A[13]*B[4] + A[14]*B[8]  + A[15]*B[12];\n    mtmp[13] = A[12]*B[1] + A[13]*B[5] + A[14]*B[9]  + A[15]*B[13];\n    mtmp[14] = A[12]*B[2] + A[13]*B[6] + A[14]*B[10] + A[15]*B[14];\n    mtmp[15] = A[12]*B[3] + A[13]*B[7] + A[14]*B[11] + A[15]*B[15];\n};\n\nMatrix.scalarMultiply = function(A, lamda) {\n    for(var i=0 ; i < 9; i++)\n        A[i] *= lamda;\n    return A;\n};\n\nMatrix.add3x3 = function(A, B) {\n    for(var i=0 ; i < 9; i++)\n        A[i] += B[i];\n    return A;\n};\n\nMatrix.add4x4 = function(A, B) {\n    for(var i=0 ; i < 16; i++)\n        A[i] += B[i];\n    return A;\n};\n\nMatrix.subtract3x3 = function(A, B) {\n    for(var i=0 ; i < 9; i++)\n        A[i] -= B[i];\n    return A;\n};\n\nMatrix.subtract4x4 = function(A, B) {\n    for(var i=0 ; i < 16; i++)\n        A[i] -= B[i];\n    return A;\n};\n\n/* THE BELOW ARE ALL STILL 3X3 */\nMatrix.transpose = function(A) {\n    var mtmp = A;\n    mtmp[1] = A[3];\n    mtmp[3] = A[1];\n    mtmp[2] = A[6];\n    mtmp[6] = A[2];    \n    mtmp[5] = A[7];\n    mtmp[7] = A[5];\n    return mtmp;\n};\n\nMatrix.determinant = function(A) {\n    return  ( A[0] * (A[4]*A[8] - A[5]*A[7]) ) - \n            ( A[1] * (A[3]*A[8] - A[5]*A[6]) ) +\n            ( A[2] * (A[3]*A[7] - A[4]*A[6]) );\n};\n\nMatrix.ajugate = function(A) {\n    var At = Matrix.transpose(A);\n    var mcfA = []; // matrix of cofactors\n    mcfA[0] = (At[4] * At[8]) - (At[5] * At[7]);\n    mcfA[1] = (At[3] * At[8]) - (At[5] * At[6]);\n    mcfA[2] = (At[3] * At[7]) - (At[4] * At[6]);\n    mcfA[3] = (At[1] * At[8]) - (At[2] * At[7]);\n    mcfA[4] = (At[0] * At[8]) - (At[2] * At[6]);\n    mcfA[5] = (At[0] * At[7]) - (At[1] * At[6]);    \n    mcfA[6] = (At[1] * At[5]) - (At[2] * At[4]);\n    mcfA[7] = (At[0] * At[5]) - (At[2] * At[3]);\n    mcfA[8] = (At[0] * At[4]) - (At[1] * At[3]);\n    var mask = [+1, -1, +1, -1, +1, -1, +1, -1, +1];\n    return Matrix.scalarMultiply(A, mask);\n};\n\nMatrix.invert = function(A) {\n    var aj = Matrix.ajugate(A);\n    var det = Matrix.determinant(A);\n    return Matrix.scalarMultiply(aj, 1 / det);\n};\n\n/******************************\n *  GENERAL HELPER FUNCTIONS  *\n ******************************/\nMatrix.equals = function(A, B) {\n    var i = 0, EPS = 1E-5, N = A.length;\n    var valid = B.length === N ? true : false; \n    while(valid === true && i < N) {\n        valid = ( Math.abs(A[i] - B[i]) < EPS );\n        i++;\n    }\n    return valid;\n};\n\nMatrix.print = function(A, sep) {\n    var N = A.length == 16 ? 4 : 3;\n    sep = typeof sep === 'undefined' ? '</br>' : sep;\n    var ms = \"\";\n    for(var i = 0; i < N; i++) {\n        for(var j = 0; j < N; j++)\n            ms += this.m[i * N + j];\n        ms += sep;\n    }\n    return ms;\n};\n\nMatrix.toString = function(A) {\n    // TO DO    - does it make sense to have a toString method anymore?\n    //          - should I simply rename print?\n};\n\n"]],"start1":0,"start2":0,"length1":0,"length2":5534}]],"length":5534}
{"contributors":[],"silentsave":false,"ts":1349376959095,"patch":[[{"diffs":[[1,"// TODO: check with oli re: the operations over 3x3, 4x4.\n//       should we operate in 3x3 and embed in 4x4 or \n//       or operate 4x4, where does that leave us for invert() \n//       i have assumed for now here possible operate 3x3 and embed (efficiency?)\n\n"],[0,"/***************************"]],"start1":0,"start2":0,"length1":28,"length2":288}]],"length":5794,"saved":false}
{"ts":1349376980921,"patch":[[{"diffs":[[0," *  "],[-1,"SETTER"],[1,"FACTORY"],[0," FUN"]],"start1":751,"start2":751,"length1":14,"length2":15}]],"length":5795,"saved":false}
{"ts":1349378837222,"patch":[[{"diffs":[[-1,"// TODO: check with oli re: the operations over 3x3, 4x4.\n//       should we operate in 3x3 and embed in 4x4 or \n//       or operate 4x4, where does that leave us for invert() \n//       i have assumed for now here possible operate 3x3 and embed (efficiency?)\n\n"],[0,"/***"]],"start1":0,"start2":0,"length1":264,"length2":4}]],"length":5535,"saved":false}
